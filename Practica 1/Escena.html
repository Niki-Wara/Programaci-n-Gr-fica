<!DOCTYPE HTML>
<html lang="es">
<head>
    <title>Escena Nocturna</title>
    <meta charset="utf-8">
    <style>
        body {
            text-align: center;
            background-color: #0b132b; /* Fondo noche oscuro */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <canvas id="webglcanvas" width="800" height="600"></canvas>
    <noscript><p><b>Lo siento, pero esta página requiere JavaScript.</b></p></noscript>

    <!-- Shaders -->
    <script id="vs" type="vertex">
        #version 300 es
        in vec2 a_position;
        uniform mat4 u_matrix;
        uniform vec4 u_color;
        out vec4 v_color;
        void main() {
            gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);
            v_color = u_color;
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/gl-matrix-min.js"></script>

    <script id="fs" type="fragment">
        #version 300 es
        precision mediump float;
        in vec4 v_color;
        out vec4 outColor;
        void main() {
            outColor = v_color;
        }
    </script>

    <script>
        "use strict";
        let gl, program;
        let matrixLocation, colorLocation, positionBuffer;

        function identityMatrix() {
            return [1,0,0,0,
                    0,1,0,0,
                    0,0,1,0,
                    0,0,0,1];
        }

        function compileShader(gl, type, source) {
            let shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            let program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        // Función para crear círculo (usada para luna y estrellas)
        function createCircleVertices(cx, cy, radius, numSegments) {
            let vertices = [cx, cy];
            for (let i = 0; i <= numSegments; i++) {
                let angle = (i / numSegments) * 2 * Math.PI;
                vertices.push(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius);
            }
            return vertices;
        }

        function dibujarLuna(gl, matrixLocation, colorLocation) {
            const vertices = createCircleVertices(0.6, 0.7, 0.15, 40);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.uniform4fv(colorLocation, [0.9, 0.9, 1.0, 1]);
            gl.uniformMatrix4fv(matrixLocation, false, identityMatrix());
            gl.drawArrays(gl.TRIANGLE_FAN, 0, vertices.length / 2);
        }
        function dibujarEstrellas(gl, matrixLocation, colorLocation) {
            // ============================
            // Estrellas fijas
            // ============================
            const estrellas = [
                [0.29, 0.95, 0.015, [1, 1, 1, 1]],       // blanca brillante
                [-0.3, 0.8, 0.025, [0.9, 0.9, 1, 1]],    // azulada
                [0.8, 0.85, 0.02, [1, 1, 0.8, 1]],       // amarillenta
                [-0.7, 0.7, 0.01, [1, 1, 1, 0.7]],       // tenue
                [0.5, 0.95, 0.03, [1, 0.95, 0.9, 1]],    // grande y cálida
                [0.0, 0.85, 0.012, [0.8, 0.9, 1, 0.9]],  // azul tenue
                [-0.5, 0.95, 0.02, [1, 1, 1, 1]],        // neutra
                [0.65, 0.75, 0.015, [1, 1, 0.85, 1]],    // amarilla clara
                [0.1, 0.7, 0.008, [1, 1, 1, 0.6]],       // muy pequeña
                [-0.2, 0.9, 0.018, [1, 0.95, 1, 1]]      // con tinte rosado
            ];

            estrellas.forEach(([cx, cy, r, color]) => {
                // Estrella circular
                const vertices = createCircleVertices(cx, cy, r, 10);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                gl.uniform4fv(colorLocation, color);
                gl.uniformMatrix4fv(matrixLocation, false, identityMatrix());
                gl.drawArrays(gl.TRIANGLE_FAN, 0, vertices.length / 2);

                // Destellos en cruz
                if (r > 0.015) {
                    const destellos = [
                        [cx - r * 2.5, cy, cx + r * 2.5, cy], // horizontal largo
                        [cx, cy - r * 2.5, cx, cy + r * 2.5], // vertical largo
                        [cx - r * 1.8, cy - r * 1.8, cx + r * 1.8, cy + r * 1.8], // diagonal ↘
                        [cx - r * 1.8, cy + r * 1.8, cx + r * 1.8, cy - r * 1.8]  // diagonal ↙
                    ];
                    destellos.forEach(line => {
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(line), gl.STATIC_DRAW);
                        gl.uniform4fv(colorLocation, [1, 1, 1, 0.6]);
                        gl.drawArrays(gl.LINES, 0, 2);
                    });
                }

            });
        }
        function dibujarMontanas(gl, matrixLocation, colorLocation) {
            const montanas = [
                // ============================
                // Montaña izquierda (oscura)
                // ============================
                {
                    vertices: [
                        -1.2, -0.5,
                        -0.5, 0.5,  // cima izquierda
                        0.0, -0.5
                    ],
                    color: [0.12, 0.18, 0.25, 1]
                },
                // Zona iluminada izquierda
                {
                    vertices: [
                        -0.7, -0.5,
                        -0.5, 0.5,
                        -0.2, -0.5
                    ],
                    color: [0.18, 0.28, 0.38, 1]
                },

                // ============================
                // Montaña central (más alta)
                // ============================
                {
                    vertices: [
                        -0.6, -0.5,
                        0.2, 0.9,   // cima alta
                        1.0, -0.5
                    ],
                    color: [0.18, 0.25, 0.35, 1]
                },
                // Lado iluminado central
                {
                    vertices: [
                        0.2, 0.9,
                        0.7, -0.5,
                        -0.1, -0.5
                    ],
                    color: [0.25, 0.35, 0.48, 1]
                },

                // ============================
                // Montaña derecha (baja)
                // ============================
                {
                    vertices: [
                        0.2, -0.5,
                        0.8, 0.4,
                        1.4, -0.5
                    ],
                    color: [0.15, 0.2, 0.3, 1]
                },
                // Lado iluminado derecha
                {
                    vertices: [
                        0.5, -0.5,
                        0.8, 0.4,
                        1.2, -0.5
                    ],
                    color: [0.22, 0.3, 0.42, 1]
                }
            ];

            // Dibujar montañas base + luces
            montanas.forEach(m => {
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(m.vertices), gl.STATIC_DRAW);
                gl.uniform4fv(colorLocation, m.color);
                gl.uniformMatrix4fv(matrixLocation, false, identityMatrix());
                gl.drawArrays(gl.TRIANGLES, 0, m.vertices.length / 2);
            });
        // ============================
        // Picos nevados con luz/sombra
        // ============================
        const picos = [
            // Pico nevado central (montaña central con cima en 0.2, 0.9)
            {
                // Lado iluminado (derecha)
                vertices: [
                    0.2, 0.9,   // cima
                    0.4, 0.55,  // bajada derecha
                    0.1, 0.55   // unión centro
                ],
                color: [1.0, 1.0, 1.0, 1]  // blanco brillante
            },
            {
                // Lado en sombra (izquierda)
                vertices: [
                    0.2, 0.9,   // cima
                    -0.01, 0.55, // bajada izquierda
                    0.1, 0.55   // centro bajo
                ],
                color: [0.85, 0.9, 1.0, 1]  // azul sombra
            },

            // Pico nevado derecho (montaña con cima en 0.8, 0.4)
            {
                // Lado iluminado
                vertices: [
                    0.8, 0.4,   // cima
                    0.95, 0.2,  // bajada derecha
                    0.75, 0.2   // unión centro
                ],
                color: [0.95, 0.95, 1.0, 1]
            },
            {
                // Lado en sombra
                vertices: [
                    0.8, 0.4,   // cima
                    0.65, 0.2,  // bajada izquierda
                    0.75, 0.2   // centro bajo
                ],
                color: [0.8, 0.85, 0.95, 1]
            }
        ];

            picos.forEach(p => {
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(p.vertices), gl.STATIC_DRAW);
                gl.uniform4fv(colorLocation, p.color);
                gl.uniformMatrix4fv(matrixLocation, false, identityMatrix());
                gl.drawArrays(gl.TRIANGLES, 0, p.vertices.length / 2);
            });
        }


        // ============================
        // ÁRBOLES VARIADOS
        // ============================
        function dibujarArbol(gl, matrixLocation, colorLocation, x, y, tipo="frondoso", escala=1) {
            if (tipo === "frondoso") {
                // --- Tronco ---
                const tronco = [
                    x - 0.03*escala, y, 
                    x + 0.03*escala, y, 
                    x + 0.025*escala, y + 0.25*escala, 
                    x - 0.025*escala, y + 0.25*escala
                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tronco), gl.STATIC_DRAW);
                gl.uniform4fv(colorLocation, [0.45, 0.25, 0.1, 1]);
                gl.drawArrays(gl.TRIANGLE_FAN, 0, tronco.length/2);

                // --- Copa redonda ---
                const copas = [
                    { dx: 0, dy: 0.3*escala, r: 0.15*escala, color: [0.1, 0.6, 0.2, 1] },   
                    { dx: -0.1*escala, dy: 0.25*escala, r: 0.12*escala, color: [0.0, 0.5, 0.15, 1] }, 
                    { dx: 0.1*escala, dy: 0.25*escala, r: 0.12*escala, color: [0.15, 0.7, 0.25, 1] }  
                ];

                copas.forEach(c => {
                    const circle = createCircleVertices(x + c.dx, y + c.dy, c.r, 20);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(circle), gl.STATIC_DRAW);
                    gl.uniform4fv(colorLocation, c.color);
                    gl.drawArrays(gl.TRIANGLE_FAN, 0, circle.length/2);
                });
            }

            else if (tipo === "pino") {
                // Tronco delgado
                const tronco = [
                    x - 0.02*escala, y,
                    x + 0.02*escala, y,
                    x + 0.015*escala, y + 0.25*escala,
                    x - 0.015*escala, y + 0.25*escala
                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tronco), gl.STATIC_DRAW);
                gl.uniform4fv(colorLocation, [0.4, 0.2, 0.1, 1]);
                gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

                // Copa triangular (tres niveles)
                const copas = [
                    [x, y+0.25*escala, x-0.15*escala, y+0.15*escala, x+0.15*escala, y+0.15*escala],
                    [x, y+0.35*escala, x-0.12*escala, y+0.25*escala, x+0.12*escala, y+0.25*escala],
                    [x, y+0.45*escala, x-0.1*escala, y+0.35*escala, x+0.1*escala, y+0.35*escala],
                ];
                copas.forEach(tri => {
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tri), gl.STATIC_DRAW);
                    gl.uniform4fv(colorLocation, [0.0, 0.4+Math.random()*0.2, 0.0, 1]);
                    gl.drawArrays(gl.TRIANGLES, 0, 3);
                });
            }

            else if (tipo === "retoño") {
                // Pequeño tallo
                const tronco = [
                    x - 0.01*escala, y,
                    x + 0.01*escala, y,
                    x + 0.008*escala, y + 0.08*escala,
                    x - 0.008*escala, y + 0.08*escala
                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tronco), gl.STATIC_DRAW);
                gl.uniform4fv(colorLocation, [0.3, 0.2, 0.1, 1]);
                gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

                // Hojas pequeñas
                const hoja = createCircleVertices(x, y+0.12*escala, 0.05*escala, 12);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(hoja), gl.STATIC_DRAW);
                gl.uniform4fv(colorLocation, [0.0, 0.7, 0.2, 1]);
                gl.drawArrays(gl.TRIANGLE_FAN, 0, hoja.length/2);
            }
        }

        class Madre {
                constructor(gl) {

                    /* Las coordenadas cartesianas (x, y) */
                    var vertices = [
                    // Cuerpo
                    -0.65,-0.13,  // 0
                    -0.65,0.22,   // 1
                    -0.5,0.4,     // 2
                    -0.65,-0.13,  // 3
                    -0.5,0.4,     // 4
                    -0.5,0.05,    // 5
                
                    // Brazos
                    -0.1, 0.05,   // 6
                    -0.5, 0.05,   // 7
                    -0.5, 0.6,    // 8
                
                    // Piernas
                    -0.5, -0.4,   // 9
                    -0.88,-0.4,   // 10
                    -0.5, 0.05,   // 11
                
                    // Pie derecho
                    -0.38, -0.55, // 12
                    -0.5, -0.55,  // 13
                    -0.5, -0.35,  // 14

                    // Pie izquierdo
                    -0.94, -0.58, // 15
                    -0.94,-0.4,   // 16
                    -0.81, -0.4,  // 17
                    ];

                    /* Cabeza */

                    var verticesCabeza = new Float32Array(360 * 2);

                    // Desplazamiento (-0.5, 0.72)
                    let radio = 0.1;
                    let k = 0;
                    /* Lee los vértices (x,y) */
                    for (var i = 0; i < 360; i++) {
                    verticesCabeza[k++] = -0.5 + radio * Math.cos(i * Math.PI / 180);
                    verticesCabeza[k++] = 0.72 + radio * Math.sin(i * Math.PI / 180);
                    }

                    this.madreVAO = gl.createVertexArray();
                    gl.bindVertexArray(this.madreVAO);

                    var codigoVertices = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                    gl.enableVertexAttribArray(0);
                    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

                    this.cabezaVAO = gl.createVertexArray();
                    gl.bindVertexArray(this.cabezaVAO);

                    var codigoVerticesCabeza = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, codigoVerticesCabeza);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesCabeza), gl.STATIC_DRAW);
                    gl.enableVertexAttribArray(0);
                    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

                    gl.bindVertexArray(null);
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                }

        dibuja(gl) {
        gl.bindVertexArray(this.madreVAO);

        // Cuerpo
        gl.uniform4fv(colorLocation, [0.2, 0.3, 0.8, 1]); // vestido azul
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        // Brazos
        gl.uniform4fv(colorLocation, [1.0, 0.85, 0.7, 1]); // piel
        gl.drawArrays(gl.TRIANGLES, 6, 3);

        // Piernas
        gl.uniform4fv(colorLocation, [0.4, 0.2, 0.1, 1]); // marrón
        gl.drawArrays(gl.TRIANGLES, 9, 3);

        // Pie derecho
        gl.uniform4fv(colorLocation, [0.1, 0.1, 0.1, 1]); // negro
        gl.drawArrays(gl.TRIANGLES, 12, 3);

        // Pie izquierdo
        gl.uniform4fv(colorLocation, [0.1, 0.1, 0.1, 1]); // negro
        gl.drawArrays(gl.TRIANGLES, 15, 3);

        // Cabeza
        gl.bindVertexArray(this.cabezaVAO);
        gl.uniform4fv(colorLocation, [1.0, 0.85, 0.7, 1]); // piel
        gl.drawArrays(gl.TRIANGLE_FAN, 0, 360);

        gl.bindVertexArray(null);
        }

                }
        class Niña {
        constructor(gl) {
            var vertices = [
            // Brazo derecho (levantado hacia arriba)
            -0.1, 0.0,
            -0.3, 0.3,
            -0.05, 0.15,

            // Brazo izquierdo (levantado hacia arriba)
            -0.1, 0.0,
            -0.05, 0.15,
            0.1, 0.3,

            // Cuerpo (vestido triangular)
            -0.2, -0.25,
            0.0, 0.0,
            0.2, -0.25,

            // Pierna derecha
            -0.05, -0.25,
            -0.05, -0.5,
            -0.15, -0.5,

            // Pierna izquierda
            0.05, -0.25,
            0.15, -0.5,
            0.05, -0.5,

            // Falda 
            -0.25, -0.25,
            0.25, -0.25,
            0.0, 0.0
            ];

            var verticesCabeza = new Float32Array(360 * 2);
            let radio = 0.07, k = 0;
            for (var i = 0; i < 360; i++) {
            verticesCabeza[k++] = 0.0 + radio * Math.cos(i * Math.PI / 180);
            verticesCabeza[k++] = 0.15 + radio * Math.sin(i * Math.PI / 180);
            }

            this.ninaVAO = gl.createVertexArray();
            gl.bindVertexArray(this.ninaVAO);
            var codigoVertices = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

            this.cabezaVAO = gl.createVertexArray();
            gl.bindVertexArray(this.cabezaVAO);
            var codigoVerticesCabeza = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoVerticesCabeza);
            gl.bufferData(gl.ARRAY_BUFFER, verticesCabeza, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }

        dibuja(gl) {
        gl.bindVertexArray(this.ninaVAO);

        // Brazos
        gl.uniform4fv(colorLocation, [1, 0.7, 0.7, 1]);
        gl.drawArrays(gl.TRIANGLES, 0, 3);
        gl.drawArrays(gl.TRIANGLES, 3, 3);

        // Cuerpo / vestido
        gl.uniform4fv(colorLocation, [1, 0.4, 0.8, 1]);
        gl.drawArrays(gl.TRIANGLES, 6, 3);

        // Pierna derecha
        gl.uniform4fv(colorLocation, [0.8, 0.6, 0.4, 1]);
        gl.drawArrays(gl.TRIANGLES, 9, 3);

        // Pierna izquierda
        gl.uniform4fv(colorLocation, [0.8, 0.6, 0.4, 1]);
        gl.drawArrays(gl.TRIANGLES, 12, 3);

        // Falda
        gl.uniform4fv(colorLocation, [1, 0.6, 0.9, 1]);
        gl.drawArrays(gl.TRIANGLES, 15, 3);

        // Cabeza
        gl.bindVertexArray(this.cabezaVAO);
        gl.uniform4fv(colorLocation, [1, 0.8, 0.6, 1]);
        gl.drawArrays(gl.TRIANGLE_FAN, 0, 360);

        gl.bindVertexArray(null);
        }

        }

        function dibujarSuelo(gl, matrixLocation, colorLocation) {
            // ============================
            // BASE DEL SUELO
            // ============================
            const suelo = [
                -1.2, -0.5,
                1.2, -0.5,
                1.2, -1.0,
                -1.2, -1.0
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(suelo), gl.STATIC_DRAW);
            gl.uniform4fv(colorLocation, [0.0, 0.3, 0.0, 1]); // verde oscuro
            gl.uniformMatrix4fv(matrixLocation, false, identityMatrix());
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

            // ============================
            // PASTO (franjas verdes claras)
            // ============================
            for (let i = 0; i < 3; i++) {
                const pasto = [
                    -1.2, -0.5 - i*0.15,
                    1.2, -0.5 - i*0.15,
                    1.2, -0.65 - i*0.15,
                    -1.2, -0.65 - i*0.15
                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pasto), gl.STATIC_DRAW);
                gl.uniform4fv(colorLocation, [0.1, 0.5 - i*0.1, 0.1, 1]);
                gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
            }

            // ============================
            // FLORES (círculos pequeños)
            // ============================
            const flores = [
                [-0.8, -0.6], [-0.6, -0.9],
                [0.7, -0.7], [0.9, -0.55],
                [0.1, -0.6], [-0.2, -0.6]
            ];
            flores.forEach(([cx, cy]) => {
                const vertices = createCircleVertices(cx, cy, 0.03, 12);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                gl.uniform4fv(colorLocation, [Math.random(), Math.random()*0.5+0.5, Math.random(), 1]); // colores vivos
                gl.uniformMatrix4fv(matrixLocation, false, identityMatrix());
                gl.drawArrays(gl.TRIANGLE_FAN, 0, vertices.length/2);
            });

        }
        let bosque = [];

        function generarBosqueFijo() {
            const tipos = ["frondoso", "pino", "retoño"];
            const numArboles = 20;

            bosque = [];

            for (let i = 0; i < numArboles; i++) {
                let x = -1 + Math.random() * 2;   
                let y = -0.5;                     

                let escala = 0.5 + Math.random() * 0.2;

                let tipo = tipos[Math.floor(Math.random() * tipos.length)];

                bosque.push({x, y, tipo, escala});
            }
        }
        function dibujarBosque(gl, matrixLocation, colorLocation) {
            bosque.forEach(arbol => {
                dibujarArbol(gl, matrixLocation, colorLocation, arbol.x, arbol.y, arbol.tipo, arbol.escala);
            });
        }

        function dibujarEscena() {
            gl.clear(gl.COLOR_BUFFER_BIT);
            dibujarSuelo(gl, matrixLocation, colorLocation);   // <--- ahora el suelo
            dibujarMontanas(gl, matrixLocation, colorLocation);
            dibujarLuna(gl, matrixLocation, colorLocation);
            dibujarEstrellas(gl, matrixLocation, colorLocation);
            dibujarBosque(gl, matrixLocation, colorLocation);

            let madre = new Madre(gl);
            let nina  = new Niña(gl);

            let matrizMadre = glMatrix.mat4.create();
            glMatrix.mat4.translate(matrizMadre, matrizMadre, [0.1, -0.5, 0]); 
            glMatrix.mat4.scale(matrizMadre, matrizMadre, [-0.2, 0.2, 1]);
            gl.uniformMatrix4fv(matrixLocation, false, matrizMadre);
            madre.dibuja(gl);

            let matrizNina = glMatrix.mat4.create();
            glMatrix.mat4.translate(matrizNina, matrizNina, [-0.05, -0.5, 0]); 
            glMatrix.mat4.scale(matrizNina, matrizNina, [0.18, 0.18, 1]);
            gl.uniformMatrix4fv(matrixLocation, false, matrizNina);
            nina.dibuja(gl);

            // Reset
            gl.uniformMatrix4fv(matrixLocation, false, new Float32Array(identityMatrix()));

        }

        function main() {
            let canvas = document.getElementById("webglcanvas");
            gl = canvas.getContext("webgl2");
            if (!gl) { alert("Tu navegador no soporta WebGL2."); return; }

            let vertexShader = compileShader(gl, gl.VERTEX_SHADER, document.getElementById("vs").text.trim());
            let fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, document.getElementById("fs").text.trim());
            program = createProgram(gl, vertexShader, fragmentShader);
            gl.useProgram(program);

            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            let positionAttributeLocation = gl.getAttribLocation(program, "a_position");
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

            matrixLocation = gl.getUniformLocation(program, "u_matrix");
            colorLocation = gl.getUniformLocation(program, "u_color");

            gl.clearColor(0.05, 0.05, 0.15, 1);

            generarBosqueFijo();

            dibujarEscena();
        }

        window.onload = main;
    </script>
</body>
</html>
