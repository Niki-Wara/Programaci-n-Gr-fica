<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Encuentra el Par</title>
  <style>
    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background: linear-gradient(135deg, #1e3c72, #2a5298);
      color: #fff;
      font-family: Arial, sans-serif;
    }
    #hud {
      margin-bottom: 8px;
      font-size: 14px;
    }
    #mensaje {
      font-size: 18px;
      font-weight: bold;
      margin-top: 8px;
      color: #ffdc00;
    }
    button {
      margin-left: 8px;
      padding: 4px 8px;
      border: none;
      border-radius: 5px;
      background: #ff851b;
      color: white;
      cursor: pointer;
      font-weight: bold;
      font-size: 13px;
    }
    button:hover { background: #ff6347; }
    canvas {
      border: 3px solid #fff;
      border-radius: 10px;
      box-shadow: 0 0 15px rgba(0,0,0,0.5);
      width: 480px;
      height: 480px;
    }
  </style>
</head>
<body>
  <div id="hud">
    Tiempo: <span id="tiempo">0</span>s
    <button onclick="reiniciar()">Reiniciar</button>
  </div>
  <canvas id="webglcanvas" width="480" height="480"></canvas>
  <div id="mensaje"></div>


<script id="vs" type="vertex">
#version 300 es
uniform mat4 uMatrizProyeccion;
uniform mat4 uMatrizVista;
uniform mat4 uMatrizModelo;
layout(location = 0) in vec2 aVertices;
void main() {
    gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 0.0, 1.0);
}
</script>


<script id="fs" type="fragment">
#version 300 es
precision mediump float;
uniform vec4 uColor;
out vec4 color;
void main() {
    color = uColor;
}
</script>

<script>
/* Matriz Identidad */
function identidad(r) {
    r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = 0;
    r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = 0;
    r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
    r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
}

/* Traslación - glTranslatef */
function traslacion(matriz, tx, ty, tz) {
    var r = new Array(16);
    r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = tx;
    r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = ty;
    r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
    r[3] = 0; r[7] = 0; r[11] = 0; r[15] =  1;
    multiplica(matriz, matriz, r);
}
/* Escalación - glScalef */
function escalacion(matriz, sx, sy, sz) { 
    let r = new Array(16);
    r[0] = sx; r[4] =  0; r[ 8] =  0; r[12] =  0;
    r[1] =  0; r[5] = sy; r[ 9] =  0; r[13] =  0;
    r[2] =  0; r[6] =  0; r[10] = sz; r[14] =  0;
    r[3] =  0; r[7] =  0; r[11] =  0; r[15] =  1;
    multiplica(matriz, matriz, r);
}
/* Proyección Paralela - glOrtho */
function ortho(r, izq, der, abj, arr, cerca, lejos) {
    r[0] = 2/(der - izq); r[4] =             0; r[ 8] =                  0; r[12] =         -(der + izq)/(der - izq);
    r[1] =             0; r[5] = 2/(arr - abj); r[ 9] =                  0; r[13] =         -(arr + abj)/(arr - abj);
    r[2] =             0; r[6] =             0; r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
    r[3] =             0; r[7] =             0; r[11] =                  0; r[15] =                                1;
}
/* Multiplicación de matrices de 4 x 4 */
function multiplica(c, a, b) {
    let r = new Array(16);
    let i, j, k;
    for (i = 0; i < 4; i++){
    for (j = 0; j < 4; j++){
        let s = 0;
        for (k = 0; k < 4; k++)
        s = s + a[i + k * 4] * b[k + j * 4];
        r[i + j * 4] = s;
    }
    }
    for (i = 0; i < 16; i++)
    c[i] = r[i];
}
let canvas, gl;
let uColor, uMatrizProyeccion, uMatrizVista, uMatrizModelo;
let MatrizProyeccion = new Array(16), MatrizVista = new Array(16), MatrizModelo = new Array(16);
let VAO;

let gridSize = 4;
let spacing = 0.05;
let cardSize = 2/gridSize - spacing;
let cartas = [];
let firstCard = null, secondCard = null;
let coloresBase = ["#FF4136","#0074D9","#2ECC40","#FFDC00","#B10DC9","#FF851B","#7FDBFF","#01FF70"];
let colores = [];
let tiempo=0, temporizador=null;
let juegoTerminado=false;

function generarCartas(){
    cartas=[];
    colores=coloresBase.concat(coloresBase);
    colores.sort(()=>Math.random()-0.5);
    let totalWidth=gridSize*cardSize + (gridSize-1)*spacing;
    let offsetX=-totalWidth/2 + cardSize/2;
    let offsetY=-totalWidth/2 + cardSize/2;
    for(let y=0;y<gridSize;y++){
        for(let x=0;x<gridSize;x++){
            let idx=y*gridSize+x;
            cartas.push({
                x: offsetX + x*(cardSize+spacing),
                y: offsetY + y*(cardSize+spacing),
                color: colores[idx],
                estado:'oculta'
            });
        }
    }
}

function dibujaCarta(carta){
    identidad(MatrizModelo);
    traslacion(MatrizModelo,carta.x,carta.y,0);
    escalacion(MatrizModelo,cardSize/2,cardSize/2,1);
    gl.uniformMatrix4fv(uMatrizModelo,false,MatrizModelo);

    if(carta.estado==='oculta') gl.uniform4f(uColor,0.3,0.3,0.3,1);
    else{
        let c=carta.color;
        let r=parseInt(c.slice(1,3),16)/255;
        let g=parseInt(c.slice(3,5),16)/255;
        let b=parseInt(c.slice(5,7),16)/255;
        gl.uniform4f(uColor,r,g,b,1);
    }

    gl.bindVertexArray(VAO);
    gl.drawArrays(gl.TRIANGLES,0,6);
    gl.bindVertexArray(null);
}


function dibuja(){
    gl.clearColor(0.1,0.1,0.15,1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    for(let c of cartas) dibujaCarta(c);
    requestAnimationFrame(dibuja);
}


function puntoDentro(x,y,carta){
    let mitad=cardSize/2;
    return (carta.x-mitad<x && x<carta.x+mitad &&
            carta.y-mitad<y && y<carta.y+mitad);
}

function mouseDown(e){
    if(juegoTerminado) return;
    if(firstCard && secondCard) return;

    let rect=canvas.getBoundingClientRect();
    let x=((e.clientX-rect.left)/canvas.width)*2-1;
    let y=-(((e.clientY-rect.top)/canvas.height)*2-1);

    let carta=null;
    for(let c of cartas){
        if(c.estado==='encontrada') continue;
        if(puntoDentro(x,y,c)){
            carta=c;
            break;
        }
    }
    if(!carta) return;

    if(carta.estado==='oculta'){
        carta.estado='mostrada';
        if(!firstCard) firstCard=carta;
        else if(!secondCard){
            secondCard=carta;
            if(firstCard.color.toUpperCase()===secondCard.color.toUpperCase()){
                firstCard.estado='encontrada';
                secondCard.estado='encontrada';
                firstCard=null; secondCard=null;
                verificarVictoria();
            } else {
                setTimeout(()=>{
                    firstCard.estado='oculta';
                    secondCard.estado='oculta';
                    firstCard=null; secondCard=null;
                },800);
            }
        }
    }
}


function verificarVictoria(){
    if(cartas.every(c=>c.estado==='encontrada')){
        juegoTerminado=true;
        clearInterval(temporizador);
        document.getElementById("mensaje").textContent="¡Ganaste en "+tiempo+" segundos!";
    }
}


function reiniciar(){
    generarCartas();
    firstCard=null; secondCard=null;
    tiempo=0; juegoTerminado=false;
    document.getElementById("tiempo").textContent=tiempo;
    document.getElementById("mensaje").textContent="";
    if(temporizador) clearInterval(temporizador);
    temporizador=setInterval(()=>{
        if(!juegoTerminado){
            tiempo++;
            document.getElementById("tiempo").textContent=tiempo;
        }
    },1000);
}


function main(){
    canvas=document.getElementById("webglcanvas");
    gl=canvas.getContext("webgl2");
    gl.viewport(0,0,canvas.width,canvas.height);

    let vs=gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vs,document.getElementById("vs").text.trim());
    gl.compileShader(vs);
    let fs=gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fs,document.getElementById("fs").text.trim());
    gl.compileShader(fs);

    let prog=gl.createProgram();
    gl.attachShader(prog,vs);
    gl.attachShader(prog,fs);
    gl.linkProgram(prog);
    gl.useProgram(prog);

    let vertices=[-1,-1,1,-1,1,1,-1,-1,1,1,-1,1];
    VAO=gl.createVertexArray();
    gl.bindVertexArray(VAO);
    let VBO=gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER,VBO);
    gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertices),gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);
    gl.bindVertexArray(null);

    uColor=gl.getUniformLocation(prog,"uColor");
    uMatrizProyeccion=gl.getUniformLocation(prog,"uMatrizProyeccion");
    uMatrizVista=gl.getUniformLocation(prog,"uMatrizVista");
    uMatrizModelo=gl.getUniformLocation(prog,"uMatrizModelo");

    ortho(MatrizProyeccion,-1,1,-1,1,-1,1);
    gl.uniformMatrix4fv(uMatrizProyeccion,false,MatrizProyeccion);
    identidad(MatrizVista);
    gl.uniformMatrix4fv(uMatrizVista,false,MatrizVista);

    canvas.addEventListener("mousedown",mouseDown);
    reiniciar();
    dibuja();
}

window.onload=main;
</script>
</body>
</html>
